进程控制：
	进程创建：
		fork（）
			复制：复制的是pcb---代码共享，数据独有
			返回值：父进程返回子进程pid>0 子进程返回0
		vfork（）--父子进程公用同一块虚拟地址空间
		子进程先运行，并且是子进程退出后或子进程程序替换运行另一段程序后，父进程才开始运行

进程终止：
	终止场景：正常终止，结果符合预期;
			  正常终止：结果不符合预期；
			  异常终止：
	终止方式：main中 return     
			  exit（）库函数--做了一系列收尾操作后，才释放资源   
			  _exit（）系统调用函数--退出时候直接释放资源，退出进程
			  相互调用，上下级
	进程等待：等待子进程的退出，避免产生僵尸进程
	          子进程什么时候退出，父进程不知道，因此只能创建子进程一直等待子进程退出
			  wait   waitpid
			  阻塞：为了完成操作发起调用，但是当前如果不具备完成条件，则一直等待，直到完成
					操作
			非阻塞：为了完成操作发起的调用，但是当前如果不具备完成条件，则立即报错返回
程序替换：替换进程所运行的程序
		  将代码段虚拟地址所经过页表映射的物理地址区域（代码在内存中的位置）替换成另一块内存中代码的位置 
		新的程序有自己运行的数据，意味着虚拟地址空间不仅代码段映射位置改变了，并且数据段也需要重新初始化，
		映射到新的程序段的位置
		（回顾fork创建子进程使用写实拷贝技术的目的：就是为了防止这种情况下空间的拜拜开辟，以及数据的拷贝时间成本）
		   exec函数族：
			execl    execlp     execle
			execv    execvp     execve
			l和v的区别：命令行参数传递不同；l-参数平铺，NULL结尾   v-字符串指针数组
			l   lp   le  区别：l需要传递可执行程序文件全路径名，lp只需要传递文件名，le传递全路径，
			并且可以自定义子程序的环境变量
			
自写minishell深入理解shell原理
	获取命令行输入数据->对数据进行解析->创建子进程->程序替换